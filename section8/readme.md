동적 계획법

## learned

### 🍱동적계획법:
  * 굉장히 크고 복잡한 문제가 주어질 떄
  * 한번에 해결하기에는 힘들 때
  * 탑다운 방식은 넓은 의미에서 동적 계획법이고 (메모이제이젼해서 재귀 컷 엣지지만 뻗어나가는 방식이 점화식이랑 비슷) 작은 문제부터 큰 문제로 확장해나가는 바텀업 방식이 진짜 동적계획법이다.
    * 두 방식 다 구한 해를 기록해놓아야 한다.

    
### ↗ Bottom-Up 동적계획법
  ```물어보는 내용을 그대로 유지하면서 직관적으로 바로 답을 낼 수 있을 정도로 아주 작은단위의 문제크기로 바꿔버린다.
  작은단위의 답을 바로 구한뒤 **배열같은곳에 기록**해놓고. (ex: 1)
  조금더 큰문제로 확장한다. 그런데 바로 앞에 구해놓은 작은 문제의 답을 이용한다. (ex: 1 x 2 = 2)
  그리고 좀더 큰 문제를 확장해서.. 바로 앞에 구해놓은 문제의 답을 이용한다.(ex: 2 x 2 = 4)
  
  f(n) = 2 x f(n-1)..
  ```
  * => `점화식!`
    * 앞에 구해놓은 해들(두개를 이용할 수도 있음)을 이용해서 현재 문제답을 구하고.. 문제를 확장하고..
    * 문제를 점점 키워나가서 실제 풀려고 했던 문제의 해를 구한다.
    * => Bottom-up방식 동적 계획법!!

  * 코드 
  ```
  dy = [0] * (n+1)
  dy[1] = 1
  dy[2] = 2
  for i in range(3,n+1):
      dy[i] = dy[i-1] + dy[i-2] 
  ```


### ↘ Top-Down 동적계획법
 * **재귀 + 메모이제이션**
 * ex:
    ```
    네트워크 선 7 이 주어져있으면
    DFS(7)
    => 7m짜리 네트워크 선이 주어지면 1미터나 2미터짜리로 자르는 방법의 수를 구한다.
            마지막이 1m이면  앞에 6m가 남으니까 그 경우의 수를 구하면 된다. => dfs(6)
            마지막이 2m이면  앞에 5m가 남으니까 그 경우의 수를 구하면 된다. => dfs(5)
            DFS(7) = dfs(6) + dfs(5)!
    ```
    ```        
    이런식으로 쭉 전위순회해서
    직관적으로 알 수 있는 dfs(2): 2 return, dfs(1): 1 return 까지 들어가면
    dfs(3)은 dfs(2) + dfs(1)인 3이된다. 그리고 이 구한 값을 dy배열에 저장해놓는다.
    이런식으로 하면 다음에 dfs(3)이 나왔을 때는 dfs하지 않고 dy배열을 값을 사용하면 된다.
    ```

    * 이렇게 이미 한번 구해진 것은 **메모**를 해놓고 다음에 불필요한 재귀호출을 방지하는 것이 `메모이제이션`!!!!!!!!!
    
    * 코드
    ```
    def dfs(m):
      if dy[m] > 0:
          return dy[m]
      if m == 1 or m == 2:
          return m
      else:
          dy[m] = dfs(m-1) + dfs(m-2)
          return dy[m]
     ```
   
