동적 계획법

## learned

### 🍱동적계획법:
  * 굉장히 크고 복잡한 문제가 주어질 떄
  * 한번에 해결하기에는 힘들 때
  * 탑다운 방식은 넓은 의미에서 동적 계획법이고 (메모이제이젼해서 재귀 컷 엣지지만 뻗어나가는 방식이 점화식이랑 비슷) 작은 문제부터 큰 문제로 확장해나가는 바텀업 방식이 진짜 동적계획법이다.
    * 두 방식 다 구한 해를 기록해놓아야 한다.

    
### ↗ Bottom-Up 동적계획법
  ```물어보는 내용을 그대로 유지하면서 직관적으로 바로 답을 낼 수 있을 정도로 아주 작은단위의 문제크기로 바꿔버린다.
  작은단위의 답을 바로 구한뒤 **배열같은곳에 기록**해놓고. (ex: 1)
  조금더 큰문제로 확장한다. 그런데 바로 앞에 구해놓은 작은 문제의 답을 이용한다. (ex: 1 x 2 = 2)
  그리고 좀더 큰 문제를 확장해서.. 바로 앞에 구해놓은 문제의 답을 이용한다.(ex: 2 x 2 = 4)
  
  f(n) = 2 x f(n-1)..
  ```
  * => `점화식!`
    * 앞에 구해놓은 해들(두개를 이용할 수도 있음)을 이용해서 현재 문제답을 구하고.. 문제를 확장하고..
    * 문제를 점점 키워나가서 실제 풀려고 했던 문제의 해를 구한다.
    * => Bottom-up방식 동적 계획법!!

  * 코드 
  ```
  dy = [0] * (n+1)
  dy[1] = 1
  dy[2] = 2
  for i in range(3,n+1):
      dy[i] = dy[i-1] + dy[i-2] 
  ```


### ↘ Top-Down 동적계획법
 * **재귀 + 메모이제이션**
 * ex:
    ```
    네트워크 선 7 이 주어져있으면
    DFS(7)
    => 7m짜리 네트워크 선이 주어지면 1미터나 2미터짜리로 자르는 방법의 수를 구한다.
            마지막이 1m이면  앞에 6m가 남으니까 그 경우의 수를 구하면 된다. => dfs(6)
            마지막이 2m이면  앞에 5m가 남으니까 그 경우의 수를 구하면 된다. => dfs(5)
            DFS(7) = dfs(6) + dfs(5)!
    ```
    ```        
    이런식으로 쭉 전위순회해서
    직관적으로 알 수 있는 dfs(2): 2 return, dfs(1): 1 return 까지 들어가면
    dfs(3)은 dfs(2) + dfs(1)인 3이된다. 그리고 이 구한 값을 dy배열에 저장해놓는다.
    이런식으로 하면 다음에 dfs(3)이 나왔을 때는 dfs하지 않고 dy배열을 값을 사용하면 된다.
    ```

    * 이렇게 이미 한번 구해진 것은 **메모**를 해놓고 다음에 불필요한 재귀호출을 방지하는 것이 `메모이제이션`!!!!!!!!!
    
    * 코드
    ```
    def dfs(m):
      if dy[m] > 0:
          return dy[m]
      if m == 1 or m == 2:
          return m
      else:
          dy[m] = dfs(m-1) + dfs(m-2)
          return dy[m]
     ```
   
### 🪗 최대부분증가수열
* 경우의 수가 너무많다. => 아주 간단한 문제로 최소화 시켜서 bottom-up방식으로 해결해보자
* dy[i]에 **arr[i]을 arr배열의 마지막항으로 했을때** 만들어지는 최대값을 구하는 방식으로 해결한다 !!

  ```
  dy[i]에 arr[i]을 arr배열의 마지막항으로 했을때 만들어지는 증가수열의 가장 긴 길이를 적는다.
  dy[3] => 3번째 항인 7을 마지막으로 했을때([5,3,7]) 만들어지는 증가수열의 가장 긴 길이
  이런식으로 가장 길이가 가장 긴 증가수열 뒤에 들러붙어가며 dy에 값을 다 채워나가면 
  !!dy중 최대값!!이 부분 증가수열의 최대 길이가된다. 
  ```
* ex. 
  ```
  arr.insert(0,0) #인덱스 1부터 시작하려고
  dy = [0] *(n+1)
  dy[1]= 1 #첫번째항이 마지막항이라고 했을때 증가수열의 최대길이는 무조건1

  res= 0
  for i in range(2, n+1): #인덱스가 1부터 시작하기 때문에 n번째 항까지 돌아야한다.
      max = 0 #앞에 구해놓은 증가수열 길이 중 최대 길이를 구한다. 그 뒤에 들러붙어야 최대 길이가된다.
      for j in range(i-1,0,-1):
          if arr[j] < arr[i] and max < dy[j]: #마지막 항의 바로 앞의 항이 되려면 작아야한다.
              max = dy[j]
      dy[i] = max + 1 #마지막 항 바로 앞의 숫자가 될 수있는 숫자의 증가수열 중 가장 긴 증가수열의 뒤에 들러붙는다.
      if dy[i] < res :
          res = dy[i] #정답이 되려면 dy에서 가장 큰 값이여야한다.
  print(res)
  ```
* 최대부분증가수열 문제는 다양하게 나올수있다.
  ```
  다연결해놓고 몇개의 선을 제거하면 최대로 선을 연결할 수 있느냐?? 할수도있다.
      이러면 부분증가수열의 최대길이를 구해놓고 10-최대길이 => 제거할 선의 개수가된다.
  다리를 만드는데 양쪽 다리번호를 제공해놓고 다리는 교차할 수 없고 최대 몇개의 다리를 만들수 있느냐. 이런식으로 나오기도함.
  ```
  
### 냅색 알고리즘
* dy[j] => 가방에 j라는 무게까지 담을 수 있을 때 담을 수 있는 보석의 최대 가치
* 하나의 보석밖에 없다고 가정하고 시작하고, 하나의 보석이 끝나면 이전 보석을 포함하여 두개의 보석이 있다고 가정한다... 
* 기록된 최대가치와 계산한 값을 비교하여 최대 가치를 갱신
```
    n, m=map(int, input().split())
    dy=[0]*(m+1);
    for i in range(n):
        w, v=map(int, input().split())
        for j in range(w, m+1):
            dy[j]=max(dy[j], dy[j-w]+v)
    print(dy[m])
```
