#answer
'''
순서를 유지하면서 최대로 증가하는 부분증가수열을 만듬

arr [5,3,7,8,6,2,9,4]

8개중에 모든 증가수열 경우의수를 써봐라! 
5->7, 3->7도있고... 경우의 수가 너무많다.


모든 경우의 수를 쓰라고했을때 한개라도 빠짐없이 하려면 어떤 기준을 갖고 해야한다.
아주 간단한 문제로 최소화 시켜서 bottom-up방식으로 해결해보자

1. 5라는 숫자 하나만 있다고 생각해보자.(=주어진 수열의 마지막항이 5라고 생각해보자.) => 5라는 증가수열 1개 밖에 없다. 

2. 그다음에 3이 주어진 수열의 마지막항이 3이라고 생각해보자. ([5,3]) => 3이라는 증가수열 1개 밖에없다.

3. 7이 주어진 수열의 마지막항이라고 해보자. ([5,3,7]).
    7의 앞에 숫자를 보자. 더작으니까 3이 바로 앞의 수가 될수있다.
        그럼 그 3을 마지막으로 해서 만들 수 있는 증가수열은? 2번의 경우로 3이라는 증가수열 1개 밖에없다.
    그리고 또 전진해서 5도 7보다 작으니까 증가수열에서의 바로 앞의 항이 될 수있다.
        그렇다면 5를 마지막으로 해서 만들수 있는 증가수열은? 1번의 경우로 5라는 증가수열 1개밖에없다.
    => 3 7, 5 7의 증가수열 2개가 있다.
    
4. 8이 마지막 항이라고하면? ([5,3,7,8])
    바로 앞에 숫자를보자. 7이다.
        7을 마지막으로 해서 만들 수 있는 증가수열은? 3번의 경우로 2개가있다.
    또 전진해서 3을 바로 앞의 숫자로하면?
        3을 마지막으로해서 만들 수 있는 증가수열은 2번의 경우로 1개가있다.
    또 전진해서 5를 바로 앞의 숫자로 하면?
        5를 마지막으로해서 만들 수 있는 증가수열은 1번의 경우로 1개가있다.
    => 3 7 8, 5 7 8, 3 8, 5 8으로 4가지 경우가있다.
    
5. 6이 마지막 항이라고하면? ([5,3,7,8,6])
    8은 더 크므로 불가
    7도 더 크므로 불가
    3은 바로앞의 숫자로 올 수있다.3이 마지막항인 증가수열은 1개
    5도 바로 앞의 숫자로 올 수 있다.5가 마지막항인 증가수열은 1개
    => 3 6, 5 6으로 2가지경우가 있다.
    

-> 앞에 구한 것들을 활용해서 현재 문제를 구하고있다!!

풀이:
arr [5,3,7,8,6,2,9,4]

(i는 1부터 시작)
dy[i]에 arr[i]을 arr배열의 마지막항으로 했을때 만들어지는 증가수열의 가장 긴 길이를 적는다.
dy[3] => 3번째 항인 7을 마지막으로 했을때([5,3,7]) 만들어지는 증가수열의 가장 긴 길이

arr[1] => 증가수열: 3, 길이 1이 최대
arr[2] => 증가수열: 5, 길이 1이 최대
arr[3] => 7이 앞의 증가수열에 들러 붙으니까
          3을 마지막으로하는 증가수열의 길이에 +1, 5를 마지막으로하는 증가수열 길이에 +1 => 둘중 최대 길이는 2 
arr[4] => 7,5,3 을 마지막으로하는 증가수열의 뒤에 들러붙을 수있다.
         이중 가장 길이가 가장 긴 증가수열 뒤에 들러붙어야 가장 긴 증가수열을 만들 수있다. => 가장 긴 증가수열 길이(최대값) + 1
.
.
.
dy [1,1,2,3,2,1,4,2] 
이런식으로 가장 길이가 가장 긴 증가수열 뒤에 들러붙어야 dy에 값을 다 채워나가면 !!dy중 최대값!!이 부분 증가수열의 최대 길이가된다. 
         
'''

n = int(input())
arr = list(map(int, input().split()))
arr.insert(0,0) #인덱스 1부터 시작하려고
dy = [0] *(n+1)
dy[1]= 1 #첫번째항이 마지막항이라고 했을때 증가수열의 최대길이는 무조건1

res= 0
for i in range(2, n+1): #인덱스가 1부터 시작하기 때문에 n번째 항까지 돌아야한다.
    max = 0 #앞에 구해놓은 증가수열 길이 중 최대 길이를 구한다. 그 뒤에 들러붙어야 최대 길이가된다.
    for j in range(i-1,0,-1):
        if arr[j] < arr[i] and max < dy[j]: #마지막 항의 바로 앞의 항이 되려면 작아야한다.
            max = dy[j]
    dy[i] = max + 1 #마지막 항 바로 앞의 숫자가 될 수있는 숫자의 증가수열 중 가장 긴 증가수열의 뒤에 들러붙는다.
    if dy[i] < res :
        res = dy[i] #정답이 되려면 dy에서 가장 큰 값이여야한다.
print(res)
