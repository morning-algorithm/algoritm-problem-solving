'''
* 동적계획법:
    굉장히 크고 복잡한 문제가 주어짐.
    한번에 해결하기에는 힘들 때
    
    물어보는 내용을 그대로 유지하면서 직관적으로 바로 답을 낼 수 있을 정도로 아주 작은단위의 문제크기로 바꿔버린다.
    작은단위의 답을 바로  구한뒤 **배열같은곳에 기록**해놓고. (ex: 1)
    조금더 큰문제로 확장한다. 그런데 바로 앞에 구해놓은 작은 문제의 답을 이용한다. (ex: 1 x 2 = 2)
    그리고 좀더 큰 문제를 확장해서.. 바로 앞에 구해놓은 문제의 답을 이용한다.(ex: 2 x 2 = 4)

    => 점화식.
    
        f(n) = 2x f(n-1)..
        (앞에 구해놓은 해 두개를 이용할 수도 있음.)
        앞에 구해놓은 해들을 이용해서 현재 문제답을 구하고.. 문제를 확장하고..
        문제를 점점 키워나가서 실제 풀려고 했던 문제의 해를 구한다.
        => Bottom-up방식 동적 계획법.!!
'''
        
#answer
'''
자르는 위치가 다르면 다른 방법으로 친다
7m의 경우의수를 한방에 구하기는 힘들다.

< dy 배열 > (자르는 방법의 수) 
1m : 1개 
2m: 2개 (1+1m, 2m)

직관적으로 알 수 있는 것은 초기에 바로 기록을 해놓는다!!!!

3m: 맨 마지막 선이 1m짜리인 경우,앞에 남은 것은 2m. 2m의 경우의 수: 2개 
    맨 마지막 선이 2m짜리인 경우, 앞에 남은 것은 1m. 1m의 경우의 수: 1개
    총 3개!

4m: 맨 마지막 선이 1m짜리인 경우, 앞에 남은것은 3m. 3m 경우의 수: 3개
    맨 마지막 선이 2m짜리인 경우, 앞에 남은것은 2m. 2m 경우의 수: 2개
    총 5개!

1, 2, 3, 5 .. => f(n) = f(n-1) + f(n-2)!!!

dy = [0] * (n+1)
dy[1] = 1
dy[2] = 2
for i in range(3,n+1):
    dy[i] = dy[i-1] + dy[i-2]
'''



    


