'''
#### 퀵정렬
* * 분할정복. 병합정렬과 거의같음, 
* * 그러나 **!!전위순회!!**
    * 자신할일(파티션.분할작업)을 먼저하고 왼쪽자식, 오른쪽 자식을 탐색한다

                    Q(0,9)
           Q(0,4)             Q(6,9)
    Q(0,1)       Q(3,4)
Q(0,0) Q(1,1) => 그냥 끝나게됨(파티션 완료라고 본다)
    
'''

def Qsort(lt,rt):
    if lt<rt: #원소가 하나이면 여기에 걸려서 끝나게됨. 파티션 완료라고 본다. 

        #### 본연의 작업 (파티션 작업)  #####
        
        pos = lt #0하면 안된다! **분할된 영역의 시작지점**이어야한다.!!
        pivot = arr[rt] # 중심축/피봇값 설정.(맨앞,랜덤,맨뒤.. 성능이 달라진다)
        
        for i in range(lt,rt): #rt가 피봇이니 rt-1까지 간다.
            if arr[i] <= pivot:
                arr[i], arr[pos] = arr[pos], arr[i]
                pos+=1 
        arr[rt], arr[pos] = arr[pos], arr[rt] #rt-1까지 다 작업하면 이제 rt(pivot)값과 pos를 교환한다. 피봇값을 기준으로 왼쪽에는 작은 값만, 오른쪽에는 큰 값만 남게된다.

        ######################################


        # 본연의 일이 다 끝나고나면 pos는 분리 기준 인덱스가 된다.
        Qsort(lt,pos-1) # pos는 자기 자리를 찾았으므로 pos - 1 
        Qsort(pos+1, rt) # pos는 자기 자리를 찾았으므로 pos + 1

arr = [ 25,21,23,36,15,67,11,60,20,33]
Qsort(0,9)
print(arr)
