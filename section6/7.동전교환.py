import sys
#sys.stdin = open("input.txt","rt")

#me
''' 큰 수를 반복해서 넣는 것이 유리. 그런데 무조건 큰 수로 먼저 채워지는 것을 답으로 하면 예제 3번 커버 못함'''
def dfs(i,s,cnt):
    global res
    if s + a[i] == m: #들어갈 수 있다.=> cnt++ 그리고 res값과 비교하여 최소값이면 저장
        
        cnt+= 1
        if cnt < res:
            res = cnt
        return

    elif s + a[i] < m: # 들어갈 수 있다.=> cnt++
        dfs(i,s + a[i],cnt+1)
        if i-1 > -1:
            dfs(i,s + a[i-1],cnt+1) #지금 나를 넣을 수 있어도 나보다 더 적은 수를 넣는 것이 미래에 유리할 수 있으니 dfs의 인덱스는 그대로 두고 작은 수를 더해본다. 
        
    else: #크면 못더하고 인덱스 낮춤.
        dfs(i-1,s,cnt)
   
    
n = int(input())
a = list(map(int,input().split()))
m = int(input())
cnt = 0
res = float('inf')
ss = []
dfs(n-1,0,0) #큰 수 부터 넣는것이 유리.
print(res)

#answer
'''
Cut Edge Tech
풀이:
원소 세개- > 세개의 간선을 갖는 트리.
     D(0)
D(1) D(1) D(1)

각 간선은 원소(동전)를 나타낸다.
D(0)에서 0과 D(1)에서 1은 레벨을 나타낸다. 여기서는 동전의 개수를 나타낸다.

이것을 바탕으로
dfs(레벨(a.k.a동전갯수) +1, sum + 해당 간선이 나타내는 원소)을 한다.

이때 큰 수부터 판단하는 것이 유리하고, sum이 거스름 돈을 넘어가면 더이상 볼 필요가 없으니 커트해버린다.
이렇게 뻗어나가서 sum이 거스름돈과 같아지면 레벨을 res와 비교하여 적으면 res에 저장한다.


그리고, 가장 걱정했던 것은 큰수부터 보는 것이 유리하지만 결국에는 작은 수로만 이루어진 가지로도 계속 뻗어나가지 않나? 했는데 (ex.1을 100번 더한다거나..)
뻗어나가던 중 현재 res의 레벨(a.k.a 동전갯수)를 넘어가면 답이 될 수 없으므로 더이상 볼 필요가 없는 것으로 판단해 가지를 쳐 해결 할 수가 있다.
```
if L+1 > res => DFS안하는 것으로 해결!
'''   
