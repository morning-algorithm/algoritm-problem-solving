brute-force (back tracking, state-space tree & cut edge) - dfs basic

## Retry
3,**7**,8,9,10

## Learned

### ⛽ 재귀함수 
* 재귀함수
  * 자기자신을 호출하는 함수
  * stack 이용해서 운영됨 
  * 반복문의 대체제(3,4중 for문의 코드 유연성을 대체)
  
  * ex) 3을 입력 -> 1~3을 출력하는 프로그램
    ``` 
    def dfs(x):
      if x>0: # 무한루프 방지
        dfs(x-1) #1,2,3 순서로 출력되기 위해 print 전에 재귀함수 호출. 
        print(x, end = ' ')
    ```
      * print 후에 dfs호출하면 3,2,1순으로 출력 => stack을 이용하기 때문.
      * 
      <image src="https://user-images.githubusercontent.com/60434971/126507094-730ee442-75e9-4d13-8cda-18406d3e5b7f.jpg" width="500"/><br/>
    
<br/><br/>
### 🌲 깊이 우선 탐색  
* 트리의 구조 <br/>
<image src="https://user-images.githubusercontent.com/60434971/126518908-43966f53-6ef8-4197-aac6-884ace572291.png" width="500"/><br/>

* 트리탐색
  * DFS: 깊이우선탐색
  * BFS: 넓이우선탐색 <br/><br/>

* 깊이우선탐색
  * 기본적으로 왼쪽 자식 먼저 탐색 <br/>
   <image src="https://user-images.githubusercontent.com/60434971/126519226-98205c22-a73e-409e-a304-425f96185aae.png" width="500"/><br/>

  * 전위, 중위, 후위 탐색 모두 파고 들어가다가 막히면 back하는 메커니즘은 똑같다.<br/><br/><br/>
  * **전위 순회**
    * 부모 -> 왼쪽 -> 오른쪽 순으로 출력.
    * 자기 본연의 것을 먼저 수행하고 ( 여기서는 자신을 출력 ) 왼쪽자식, 오른쪽 자식을 탐색<br/>
    
      ```
      def dfs(v):
          if x > n: 
              return
          print(v)
          dfs(v*2)
          dfs(v*2+1) 
       ```
    
    <image src="https://user-images.githubusercontent.com/60434971/126519453-74112cfc-731b-4efb-b41b-4d6d941f5766.png" width="350"/><br/>
  
  * **중위 순회**
    * 왼 -> 부 -> 오 순으로 출력.
    * 왼쪽 자식 탐색, 자신 출력, 오른쪽 자식 탐색<br/>
       ```
          dfs(v*2)
          print(v)
          dfs(v*2+1) 
       ```
    <image src="https://user-images.githubusercontent.com/60434971/126520197-0335e9ac-1bbc-4517-b8fd-e9cc92b46ca2.png" width="350"/><br/>
  
  * **후위 순회**
    * 왼 -> 오 -> 부 순으로 출력.
    * 왼쪽 자식 탐색, 자신 출력, 오른쪽 자식 탐색<br/>
        ```
          dfs(v*2)
          dfs(v*2+1) 
          print(v)
        ```
    <image src="https://user-images.githubusercontent.com/60434971/126520235-24b50815-cee8-4f1c-a9fe-9b2e6a903f47.png" width="350"/><br/>
  
    => 모두 스택에 어떻게 쌓이는지 생각해보기!
<br/><br/>
### 부분집합
* 부분집합을 구하는 문제는 **상태트리**를 쓴다. 
* 부분집합은 1이 들어가냐 안들어가냐, 2가 들어가냐 안들어가냐, 3이 들어가냐 안들어가냐 해서 2 ^ 원소의 개수 상태가 있음
* => 이를 이용해서 이진트리를 구성! 
   ```
                 1
         2               2
     3       3       3      3
   4   4   4   4   4   4  4   4
   ```
  * 왼쪽 간선: 해당 노드를 사용하는 상태 or 오른쪽 간선:해당 노드를 사용하지 않는 상태로 뻗어나감.
  * 이런 것을 상태트리라고 함. 앞으로 dfs를 잘하려면 상태트리만 잘 구성하면 됨. 그리고 그 상태트리에 의해서 재귀만 호출하면 됨!!
 
  ```
  # 원소를 사용하는 상태냐,아니냐 체크를 위해서 ch=[0]*(n+1)사용
  def dfs(v):
        if v == n+1:
              #4일 때 원소 끝까지 온거니까 출력하고 종료해야함
              #ch가 1이면 출력
        else:
              ch[v] = 1
              dfs(v+1) # 현재 원소를 사용한다고 하고 다음 원소로 넘어가기
              ch[v] = 0
              dfs(v+1) #현재 원소를 사용하지 않는다하고 다음 원소로 넘어가기
  ```
  * dfs로 더하거나, 안더하거나 해서누적 sum값을 구할때는? 
  ```
  dfs(v+1,sum+a[v]) #더하거나 
  dfs(v+1,sum) #안 더하거나 
  ```
  <br/><br/>
  
### 전역변수와 지역변수
* 함수외부에서 `cnt = 5` 
    * 전역 변수를 선언하고, 5를 할당하는 작업을 한다.
    * 전역변수: 공용. 모든 함수가 접근할 수 있음
    

* 함수 내부에서 `cnt==5`: 
    * 변수가 먼저 자기 지역변수에 있는지 검사. 없으면 전역변수를 사용.  
     => **함수는 지역변수가 우선이다!**

* 함수 내부에서 `cnt = 5`
    * 할당하는 작업은 전역 변수 유무에 상관없이 지역변수에 새로 선언.

* 만약 함수 내부에서 
    ```
    if cnt == 5:
        cnt = cnt + 1
    ```
    * 지역변수 cnt를 참조하기 전에 할당하라고 오류남!
    * 왜? 
        * 인터프리터가 먼저 언어 번역을 하기 때문
        * `cnt = cnt + 1`를 번역할 때 지역변수 cnt가 먼저 생겨버린다. 
        * `cnt == 5`이 실행될 때 지역변수 cnt가 있으므로 지역변수 사용. 그런데 cnt에 아무값이 없으므로 에러가 난다!
    * cnt를 전역변수를 사용하려면? 
        * 함수 내부에서 `global cnt`
        * global을 달면 cnt가 언어번역을 통해 지역변수가 되기 전에 전역변수라고 알려줌. => 로컬 변수를 선언하지 않음!

* 왜 리스트는 지역변수화 되지 않고 전역변수로 정상적으로 작동하느냐?
    * **함수 내부에서 `a[0] = 7` 는 a[0]를 선언하는게 아니라 a의 0번 인덱스를 참조하는 것(변경하는 것)으로 번역이된다.** 
    * 만약 함수 내부에서 `a = [7,8]` 을 하게 되면 local 리스트가 선언된다! 
    * 만약 함수내부에서 `a = a+[4]` 도 위와 마찬가지 이유로 에러가 난다!

### 순열
* key idea
    - dfs(뽑아야하는 원소의 개수(==레벨))
    - 각 원소들을 간선으로 사용.

* 중복 가능한 순열
``` 
res = [0]*뽑아야하는 원소 개수 #각 레벨에서 뽑히는 원소를 저장할 용도

for 간선 in 간선 리스트: #원소들 중 하나를 뽑는다
    res[현재레벨] = 간선 
    dfs(간선 뽑았으니까 레벨 + 1)
```


* 중복 불가능 순열은 위 로직에서 체크리스트를 추가한다. 

```
체크리스트[현재 간선] = 이미 사용 
dfs(다음레벨) #체크리스트에 이미 사용이라고 써져있는 간선으로는 뻗어나갈 수 없다.
체크리스트[현재 간선] = 미사용 # 빽하기 전에 다시 초기화를 해준다.
```   

### 파스칼의 삼각형
* 원리
```
   1    2    3     4
    1+2   2+3   3+4
    1+2+2+3 2+3+3+4
    1+2+2+2+3+3+3+4
= 1+ 2x3+ 3x3+ 4

=> 1x'1'+ 2x'3' + 3x'3'+ 4x'1'
=> 원소 1,2,3,4에 순서대로 1,3,3,1 곱한 값이 답.

n=3이면?
    1a^2 + 2ab+ 1b^2
    1 2 1 (이항계수)
n=4이면?
    1a^3 + 3a^2b + 3ab^2 + 1b^3
    1 3 3 1 (이항계수)
    3C0 3C1 3C2 3C3
    1 3/1 3x2/2x1 3x2x1/3x2x1
n=5면?
    1 4 6 4 1
    4C0 4C1 4C2 4C3 4C4
```
* 구현
```
for i in range(1,n):
    b[i] = b[i-1] * (n-i) // i #1 3/1 3x2/2x1 3x2x1/3x2x1 앞에수에다가 계속 추가
```

<br>

### ✴️ 조합
* (오름차순 기준) 뒤에 레벨에서 나오는 수는 앞 레벨에서 나오는 수보다 작다.
* 상태트리 구성: `DFS(L, s)`: D(레벨, **가지를 뻗을때 갈 수 있는 제일 작은 숫자**)
```
                  D(0,1)
           1     2     3     4
         D(1,2)
       2   3   4
    D(2,3)
```
* DFS호출 시 중복체크 필요없음!!!!!!! 어처피 다음 레벨의 가지는 자기보다 큰 수부터 시작하니까

<br><br>

### ‼️ 그래프
<image src="https://user-images.githubusercontent.com/60434971/127273145-699b94c4-e01b-4a2c-8e0e-b02d8abec651.png" width="500"/><br/>

* 인접행렬 <br/>
<image src="https://user-images.githubusercontent.com/60434971/127273222-9b6138d8-5886-4c95-afd1-7849ea8e5524.png" width="800"/><br/>

* 경로탐색
    * 한번 방문한 노드는 다시 방문하지 않도록 꼭 방문 체크 !!! 
        ```
        ch[j]= 1
        dfs(j)
        ch[j]= 0
        ```
        * back 할 때 꼭 체크 해제!

    * 경로 까지 출력하려면
       ```
        path.append(j)
        ch[j]= 1
        dfs(j)
        ch[j]= 0
        path.pop()
       ```
