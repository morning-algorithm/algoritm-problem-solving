brute-force (back tracking, state-space tree & cut edge) - dfs basic

## Learned

### ⛽ 재귀함수 
* 재귀함수
  * 자기자신을 호출하는 함수
  * stack 이용해서 운영됨 
  * 반복문의 대체제(3,4중 for문의 코드 유연성을 대체)
  
  * ex) 3을 입력 -> 1~3을 출력하는 프로그램
    ``` 
    def dfs(x):
      if x>0: # 무한루프 방지
        dfs(x-1) #1,2,3 순서로 출력되기 위해 print 전에 재귀함수 호출. 
        print(x, end = ' ')
    ```
      * print 후에 dfs호출하면 3,2,1순으로 출력 => stack을 이용하기 때문.
      * 
      <image src="https://user-images.githubusercontent.com/60434971/126507094-730ee442-75e9-4d13-8cda-18406d3e5b7f.jpg" width="500"/><br/>
    
<br/><br/>
### 🌲 깊이 우선 탐색  
* 트리의 구조 <br/>
<image src="https://user-images.githubusercontent.com/60434971/126518908-43966f53-6ef8-4197-aac6-884ace572291.png" width="500"/><br/>

* 트리탐색
  * DFS: 깊이우선탐색
  * BFS: 넓이우선탐색 <br/><br/>

* 깊이우선탐색
  * 기본적으로 왼쪽 자식 먼저 탐색 <br/>
   <image src="https://user-images.githubusercontent.com/60434971/126519226-98205c22-a73e-409e-a304-425f96185aae.png" width="500"/><br/>

  * 전위, 중위, 후위 탐색 모두 파고 들어가다가 막히면 back하는 메커니즘은 똑같다.<br/><br/><br/>
  * **전위 순회**
    * 부모 -> 왼쪽 -> 오른쪽 순으로 출력.
    * 자기 본연의 것을 먼저 수행하고 ( 여기서는 자신을 출력 ) 왼쪽자식, 오른쪽 자식을 탐색<br/>
    
      ```
      def dfs(v):
          if x > n: 
              return
          print(v)
          dfs(v*2)
          dfs(v*2+1) 
       ```
    
    <image src="https://user-images.githubusercontent.com/60434971/126519453-74112cfc-731b-4efb-b41b-4d6d941f5766.png" width="350"/><br/>
  
  * **중위 순회**
    * 왼 -> 부 -> 오 순으로 출력.
    * 왼쪽 자식 탐색, 자신 출력, 오른쪽 자식 탐색<br/>
       ```
          dfs(v*2)
          print(v)
          dfs(v*2+1) 
       ```
    <image src="https://user-images.githubusercontent.com/60434971/126520197-0335e9ac-1bbc-4517-b8fd-e9cc92b46ca2.png" width="350"/><br/>
  
  * **후위 순회**
    * 왼 -> 오 -> 부 순으로 출력.
    * 왼쪽 자식 탐색, 자신 출력, 오른쪽 자식 탐색<br/>
        ```
          dfs(v*2)
          dfs(v*2+1) 
          print(v)
        ```
    <image src="https://user-images.githubusercontent.com/60434971/126520235-24b50815-cee8-4f1c-a9fe-9b2e6a903f47.png" width="350"/><br/>
  
    => 모두 스택에 어떻게 쌓이는지 생각해보기!
<br/><br/>
### 부분집합
* 부분집합을 구하는 문제는 **상태트리**를 쓴다. 
* 부분집합은 1이 들어가냐 안들어가냐, 2가 들어가냐 안들어가냐, 3이 들어가냐 안들어가냐 해서 2 ^ 원소의 개수 상태가 있음
* => 이를 이용해서 이진트리를 구성! 
   ```
                 1
         2               2
     3       3       3      3
   4   4   4   4   4   4  4   4
   ```
  * 왼쪽 간선: 해당 노드를 사용하는 상태 or 오른쪽 간선:해당 노드를 사용하지 않는 상태로 뻗어나감.
  * 이런 것을 상태트리라고 함. 앞으로 dfs를 잘하려면 상태트리만 잘 구성하면 됨. 그리고 그 상태트리에 의해서 재귀만 호출하면 됨!!
 
  ```
  # 원소를 사용하는 상태냐,아니냐 체크를 위해서 ch=[0]*(n+1)사용
  def dfs(v):
        if v == n+1:
              #4일 때 원소 끝까지 온거니까 출력하고 종료해야함
              #ch가 1이면 출력
        else:
              ch[v] = 1
              dfs(v+1) # 현재 원소를 사용한다고 하고 다음 원소로 넘어가기
              ch[v] = 0
              dfs(v+1) #현재 원소를 사용하지 않는다하고 다음 원소로 넘어가기
  ```
  * dfs로 더하거나, 안더하거나 해서누적 sum값을 구할때는? 
  ```
  dfs(v+1,sum+a[v]) #더하거나 
  dfs(v+1,sum) #안 더하거나 
  ```
  <br/><br/>
### 전역변수와 지역변수
* 함수외부에서 `cnt = 5` 
    * 전역 변수를 선언하고, 5를 할당하는 작업을 한다.
    * 전역변수: 공용. 모든 함수가 접근할 수 있음
    

* 함수 내부에서 `cnt==5`: 
    * 변수가 먼저 자기 지역변수에 있는지 검사. 없으면 전역변수를 사용.  
     => **함수는 지역변수가 우선이다!**

* 함수 내부에서 `cnt = 5`
    * 할당하는 작업은 전역 변수 유무에 상관없이 지역변수에 새로 선언.

* 만약 함수 내부에서 
    ```
    if cnt == 5:
        cnt = cnt + 1
    ```
    * 지역변수 cnt를 참조하기 전에 할당하라고 오류남!
    * 왜? 
        * 인터프리터가 먼저 언어 번역을 하기 때문
        * `cnt = cnt + 1`를 번역할 때 지역변수 cnt가 먼저 생겨버린다. 
        * `cnt == 5`이 실행될 때 지역변수 cnt가 있으므로 지역변수 사용. 그런데 cnt에 아무값이 없으므로 에러가 난다!
    * cnt를 전역변수를 사용하려면? 
        * 함수 내부에서 `global cnt`
        * global을 달면 cnt가 언어번역을 통해 지역변수가 되기 전에 전역변수라고 알려줌. => 로컬 변수를 선언하지 않음!

* 왜 리스트는 지역변수화 되지 않고 전역변수로 정상적으로 작동하느냐?
    * **함수 내부에서 `a[0] = 7` 는 a[0]를 선언하는게 아니라 a의 0번 인덱스를 참조하는 것(변경하는 것)으로 번역이된다.** 
    * 만약 함수 내부에서 `a = [7,8]` 을 하게 되면 local 리스트가 선언된다! 
    * 만약 함수내부에서 `a = a+[4]` 도 위와 마찬가지 이유로 에러가 난다!
