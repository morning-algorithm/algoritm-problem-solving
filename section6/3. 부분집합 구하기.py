import sys
#sys.stdin = open("input.txt","rt")

#me
'''
부분집합을 먼저 생각하진 않고 출력 예제를 보고 유추했음.
이전에 수들을 계속해서 기억하려면 자료구조에 저장되고 그걸 나중에 호출된 함수에서 사용해야한다는 것.
3이 제일 나중에 넣어지고 제일 먼저 pop되려면 stack에 제일 나중에 들어가는 것 => dfs(1)부터 시작하여 dfs(3)이 제일 나중에 호출
그리고 stack에 마지막 수 까지 다 넣어지고 나서야 출력되는 것을 보고 아 먼저 탐색을하고 그 다음에 출력하는구나 생각했음'''
s = list()
def dfs(x):
      s.append(x)
      while x < n :
            x += 1
            dfs(x)
      print(' '.join(map(str,s)))
      s.pop()

n = int(input())
for x in range(1,n+1):
      dfs(x)

#answer
'''
부분집합은 1이 들어가냐 안들어가냐, 2가 들어가냐 안들어가냐, 3이 들어가냐 안들어가냐 2x2x2=8가지 상태가 있음. 공집합 제외하면 7가지
이를 이용해서 이진트리를 구성했음.
                  1
         2              2
   3       3       3      3
 4  4  4   4   4  4  4  4
=> 왼쪽 간선: 해당 노드를 사용하는 상태 or 오른쪽 간선:해당 노드를 사용하지 않는 상태로 뻗어나감.
이런 것을 상태트리라고 함. 앞으로 dfs를 잘하려면 상태트리만 잘 구성하면 됨. 그리고 그 상태트리에 의해서 재귀만 호출하면 됨!!

원소를 사용하는 상태냐,아니냐 체크를 위해서 ch=[0]*(n+1)사용

def dfs(v):
      if v == n+1:
            #4일 때 원소 끝까지 온거니까 출력하고 종료해야함
            #ch가 1이면 출력
      else:
            ch[v] = 1
            dfs(v+1) # 현재 원소를 사용한다고 하고 다음 원소로 넘어가기
            ch[v] = 0
            dfs(v+1) #현재 원소를 사용하지 않는다하고 다음 원소로 넘어가기
dfs(1) 호출!
'''
