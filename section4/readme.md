binary search & greedy Algorithm

* retry: **2,3,4,5,6**

### learned
*    결정 알고리즘 => 이분검색 사용
      *    특징: 시작, 끝 범위가 정해져 있는 경우
      * 방법: 중앙값이 답으로써 유효한지 검사 => 범위를 좁혀서 절반 날리고 더 좋은 답을 찾아서 좁혀나감. 
      -> **답이 될 수 있는 것은 res에 계속 저장하기!**
      
* 그리디 알고리즘: 문제를 풀어나가는 과정에 있어서 현재 이 단계에서 가장 좋은 것이 뭔지 보고, 그것을 선택함
     - 단계에서 가장 좋은것을 어떻게 판별?
     - 거의 대부분의 그리디문제는 **정렬**을 한다음에 차례차례 선택하면 그리디가 된다.
     
* deque:
     - 리스트의 pop(0)은, 앞으로 한칸 씩 옮겨야 하므로 비효율적임.(like 배열)
    - deque 자료구조는 앞에서도, 뒤에서도 넣었다 뺄 다 할 수 있는데 단순히 포인터를 이용하므로 더 효율적임. 땡기는 연산 x

         ``` from collections import deque
          a = deque(리스트)
          a.popleft()```
* 역수열:
         ``` for 뒤에있는 숫자부터:
               insert(자기보다 큰 수의 개수) ```
