import sys
#sys.stdin = open("input.txt","rt")

#me
'''
마지막 수 부터 시작한다.
-마지막 수는 당연히 자기보다 큰수가 하나도 없다. 
-마지막에서 두번째수는 자기보다 큰수가 최대 하나 있어야한다. 
    -없다면?  마지막 숫자 뒤에 있다. -> 마지막 수의 뒤에 배치.
    -하나 있다면? 마지막 숫자 앞에있다.
-마지막에서 세번째 수는 자기보다 큰 수가 최대 2개 있어야 한다.
    -없다면? 자기가 제일 앞에있다
    -최대 2개 있다면? 자기가 제일 뒤에있다
    -1개 라면? 배치된 수 중에서 자기 보다 큰 수는 1개있다. == 배치된 수 들 중 1번째 위치에 있다. (위치가 0부터 시작한다 가정) => 1번째 위치에 삽입 => insert(1)
-마지막에서 네번쨰 수는 자기보다 큰 수가 최대 3개 있어야 한다.
    -없다면? 자기가 제일 앞에있다
    -최대 3개 있다면? 자기가 제일 뒤에있다 
    -2개 라면? 배치된 수 중에서 자기 보다 큰 수는 2개있다. == 배치된 수 들 중 2번째 위치에 있다. (위치가 0부터 시작한다 가정) => 1번째 위치에 삽입 => insert(2)

이 과정을 반복! 
일반화하면, 뒤에서부터 그냥 insert(내 앞에있는 큰 수의 개수)하면 된다. 
'''
n = int(input())
a = list(map(int,input().split()))
r = list()

for i in range(n-1,-1,-1):
    r.insert(a[i],i+1)

for item in r:
    print(item,end=' ')
    

#answer
'''
<역수열> 
명심해야 될 것! 숫자를 오름차순으로 처리해놨기때문에 이러한 원리를 쓴다.
이미 자리잡은 숫자는 나보다 작은 숫자이니까 무시.
앞으로 들어오는 수는 나보다 큰 숫자이니까 내가 자리잡을 때 내앞으로 위치한 큰 수 개수만큼 빈칸을 남겨놓고 자신의 위치를 설정해야함.

명심해야될 것:
a[i] == 0 이면, 자기 앞의 빈공간을 전부 확보 완료했다는 것. 그리고 seq[j] == 0 이면, 누군가가 아직 차지하지 않았다는 것. => seq[j]에 i+1(0번째 인덱스는 숫자 1을 나타내므로 +1)
s[j]만 0이면? 빈칸임. 빈공간 확보했으므로 a[i]에 -1
s[j]가 0이 아니면? 누가 이미 차지하고 있으므로 a[i] -1 하지않고 그냥 넘어감.


seq=[0]*n
for i in range(n): #역수열 숫자(인덱스)
    for j in range(n): #숫자가 들어갈 seq 빈칸 찾기용 
        if a[i] == 0 and seq[j] == 0:
            seq[j]=i+1
            break
        elif seq[j] == 0:
            a[i] -=1 
'''

