data structure (stack, queue, hash, heap)

* retry: 1,2,3,**7**,9

## 🖋️ learned
- stack
  - LIFO : 나중에 들어온 것이 먼저 나온다
  - 구덩이
  - python list의 pop(), append()

* Queue
    - FIFO, 들어가는 순서대로 나온다
    - append(), popleft() / appendleft(), pop()

* 후위표기식: 컴퓨터에서 연산하는 방식,  **stack 필요**, 
    - 숫자면 출력
    - 연산자면? 스택 필요!
        - 스택 상단에 있는 것
            - 아래있는 연산자들보다 우선순위가 더 높은 연산자. (넣으려고 할때 더 높은 연산자가 있으면 꺼내고 넣어야한다. )
            
        - 연산자 우선순위
            -  / *> + - 
            - 같은 우선순위면 중위식에서 왼쪽에 있는 것이 더 높음
        - \+ \- 이면?  
          ```
            - 스택에 있는 것 다 끄집어내서 출력하고 append. 
               왜? +-는 자기보다 낮은 우선순위가 없으므로.
            - 같은 우선순위인 -,+를 만나도 스택에 있는것 전부 출력. 
               왜? 이미 스택에 있는 것이 중위식 왼쪽에 있던 것으로 우선순위 더 높음.
           
        - \* /면? 
          ``` 
          나보다 우선순위가 높은 연산자는, 같은 */가 있으면 끄집어내고 자신을 넣는다.
          
        **=> 나와 스택에 있는 것을 비교해서 나보다 우선순위가 같거나 높으면 pop해서 출력하고 자신을 append**
        
        - (를 고려하면?
           ```
            - 앞으로 연산자들은 ( 이후에 쌓인 괄호들만 처리함.
            - (면? 무조건 append하고 )를 만났을때 꺼냄.
            - )면? 여는 괄호 전까지에 있는 모든 연산자 꺼냄. 그리고 (를 pop
            
* 후위식 연산:
    - 컴퓨터가 편한 방법. 그래서 후위식으로 바꾸는 것.
    - 앞에서부터 탐색을하다가 연산자를 만나면, 앞에 두개의 피연산자로 연산하여 결과물이나옴.
    - '-' 나 '/'는 앞 피연산자에서 뒤 피연산자를 뺀다
        - 왜? 5-3은 후위식으로 53-이다. 피연산자의 순서는 바뀌지 않는다는 것 명심하기!

* enumerate
    - 리스트가 있는 경우 순서와 리스트의 값을 전달하는 기능
    - 순서가 있는 자료형(list, set, tuple, dictionary, string)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 리턴
* any()
    - any(cur[1] < x[1] for x in Q): for문 돌면서 단 한개라도 참인게 있으면 참이됨 !

* 이진트리
<image src="https://user-images.githubusercontent.com/60434971/126342431-cb0914ad-961e-4414-8cb5-8282c60253f0.jpg" width="600"/>

* 최소힙
<image src="https://user-images.githubusercontent.com/60434971/126342778-d13ed277-467c-4fc7-a922-2579817475bb.jpg" width="500"/>

  ``` 
  import heapq as hq
  hq.heappop(a)
  hq.heappush(a,n)
  hq.heapify(a) #리스트를 최소힙으로 만듦
  ```

* 최대힙
  - 기존 python의 heapq에서 **insert시에 -n붙여서, pop할때는 -붙여서 출력**
  - 최대값이 8이었다면 -8이됨. 따라서 -8이 최소값이 되므로 이 수가 힙의 루트노드가 됨.
